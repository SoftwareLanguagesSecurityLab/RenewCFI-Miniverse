/* Test program expecting original return values
*/

#include "miniverse.h"
#include "inittester.h"
#include "handlers.h"
#include <sys/mman.h>
#include <string.h>
#include <fcntl.h>
#include <stdio.h>

#include <assert.h>

//#include <signal.h>
//#include <inttypes.h>
//#include <stdbool.h>

uint8_t code_version = 0;

bool my_is_target(uintptr_t address, uint8_t *bytes){
  if( code_version == 0 && address == 0x7000004 ) return true;
  if( code_version == 1 && address == 0x7000006 ) return true;
  if( code_version == 2 && address == 0x700001b ) return true;
  if( code_version == 2 && address == 0x700000d ) return true;
  if( code_version == 2 && address == 0x7000011 ) return true;
  return false;
}

void introspect_callback(uintptr_t addr){
  printf("Address: 0x%x\n", *(&addr-1) );
  assert( *(&addr-1) == 0x700000a );
}

int main(int argc, char** argv){

	/* Hooks are currently done with linker flags, not runtime functions */
        //mmap_hook(&mmap);
        //mprotect_hook(&mprotect);
        register_handler(&my_is_target);

	/*
	0000000000000000 31d2             xor edx, edx            
	0000000000000002 0417             add al, 0x17            
	0000000000000004 42               inc edx                 
	0000000000000005 83fa04           cmp edx, 0x4            
	0000000000000008 7407             jz 0x11
	000000000000000a b804000007       mov eax, 0x7000004      
	000000000000000f ffe0             jmp eax                 
	0000000000000011 89d0             mov eax, edx            
	0000000000000013 c3               ret 
	*/
	uint8_t orig_code[] = "\x31\xd2\x04\x17\x42\x83\xfa\x04\x74\x07\xb8\x04\x00\x00\x07\xff\xe0\x89\xd0\xc3";

	/*
	0000000000000000 ba0031d204       mov edx, 0x4d23100      
	0000000000000005 17               pop ss                  
	0000000000000006 42               inc edx                 
	0000000000000007 83fa04           cmp edx, 0x4            
	000000000000000a 7407             jz 0x13                 
	000000000000000c b806000007       mov eax, 0x7000006      
	0000000000000011 ffe0             jmp eax                 
	0000000000000013 89d0             mov eax, edx            
	0000000000000015 c3               ret
	*/
	uint8_t orig_code2[] = "\xba\x00\x31\xd2\x04\x17\x42\x83\xfa\x04\x74\x07\xb8\x06\x00\x00\x07\xff\xe0\x89\xd0\xc3\x90";

	/* jnz encodes an illegal instruction that terminates a sequence after
           our valid target at inc eax if starting from a different offset */
	/* The bug I am attempting to reproduce is INCREDIBLY difficult to
	   reproduce without changing any of the original code, because it
	   depends on the relocation sorting algorithm to sort several
	   RELOC_IND relocations with the same target but different offsets
	   (which results in patching a lookup entry multiple times, and the 
	   last relocation "wins" by having its value as the one that stays.
	   This should be changed to just filter out multiple RELOC_IND
	   relocations and just use the lowest one, which should probably be
	   the original.  All of these relocations SHOULD be safe to use, but
	   the later relocation offsets point to a direct jump to the original
	   instruction, so it's a pointless extra step caused by the duplicate
	   jmp instructions generated by superset disassembly to join together
	   overlapping sequences with a jump to the original code and avoid
	   code duplication.  I probably should flag "special" jmp instructions
	   to avoid generating RELOC_IND relocations for those instructions,
	   but currently my disassembly code does not pass that info to
	   instruction generation code).  I ended up changing the relocation
	   sorting algorithm to save the headache required to get the relocs
	   in just the right order, but this does mean that this test will work
	   without actually fixing the root problem by simply making small
	   tweaks and probably wouldn't trip up an unrelated implementation.
	   I think that testing having a jump target reached by multiple code
	   offsets is useful, but it's hard to make a test that covers all the
	   possible edge cases.

	   I believe that the root cause of the bug comes from my code not
	   correctly increasing the values of last_safe_offset and
	   last_safe_reloc for jmp instructions.  This normally did not cause
	   an issue because a number of factors have to be true for it to fail:
	   -The jmp must be the last good instruction in a sequence
	   -The jmp must be a jmp target or cross a chunk boundary so padding
	    is generated
	   -The generated code for the jmp must be overwritten by other
	    generated code due to last_safe_offset not being increased enough
	   This meant that the bug only would come up in fairly complex code
	   and made it especially hard to track down.  There may be an easier
	   way to reproduce this, but it is surprisingly complicated and I had
	   the most luck with trying to reproduce the bug similiarly to the
	   real-world example I encountered that led to the bug in the first
	   place.
	*/
	/*
	0000000000000000 31c0             xor eax, eax            
	0000000000000002 57               push edi                
	0000000000000003 681b000007       push 0x700001b          
	0000000000000008 89e7             mov edi, esp            
	000000000000000a 3dd0a037f5       cmp eax, 0xf537a0d0     
	000000000000000f ff17             call dword [edi]        
	0000000000000011 85d2             test edx, edx           
	0000000000000013 0f8528f8ffff     jnz 0xfffff841          
	0000000000000019 5f               pop edi                 
	000000000000001a 5f               pop edi                 
	000000000000001b 40               inc eax                 
	000000000000001c 31d2             xor edx, edx            
	000000000000001e c3               ret
	*/
	uint8_t orig_code3[] = "\x31\xc0\x57\x68\x1b\x00\x00\x07\x89\xe7\x3d\xd0\xa0\x37\xf5\xff\x17\x85\xd2\x0f\x85\x28\xf8\xff\xff\x5f\x5f\x40\x31\xd2\xc3";

	void *code_buffer = (void*)0x7000000;
	
	mmap(code_buffer, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

	memcpy(code_buffer, orig_code, sizeof(orig_code));
	/* Try to make code executable; our mprotect hook will prevent this */
        mprotect(code_buffer, 4096, PROT_EXEC|PROT_READ);
        uint32_t res = ((uint32_t (*)(uint32_t))code_buffer)(0);
        printf("Result: %d Expected: 4\n", res );
	code_version++;
        mprotect(code_buffer, 4096, PROT_WRITE|PROT_READ);
	memcpy(code_buffer, orig_code2, sizeof(orig_code2));
        mprotect(code_buffer, 4096, PROT_EXEC|PROT_READ);
        res = ((uint32_t (*)(uint32_t))code_buffer+2)(0);
        printf("Result: %d Expected: 4\n", res );
	code_version++;
        mprotect(code_buffer, 4096, PROT_WRITE|PROT_READ);
	memcpy(code_buffer, orig_code3, sizeof(orig_code3));
        mprotect(code_buffer, 4096, PROT_EXEC|PROT_READ);
        res = ((uint32_t (*)(uint32_t))code_buffer)(0);
        printf("Result: %d Expected: 2\n", res );

	return 0;

	/* Since this isn't a library loaded in the traditional way, it doesn't have destructors
	   and therefore should execute without crashing */
}
